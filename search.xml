<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《出师表》</title>
    <url>/2023/10/12/001/</url>
    <content><![CDATA[<p>《诸葛亮出师表》写了当时蜀汉丞相诸葛亮面对国家危难，以及他在艰难险阻中，坚持忠诚为国家尽心尽力的决心和志向。</p>
<h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h2><p>诸葛亮（181年-234年），字孔明，号卧龙，汉族，蜀汉丞相，被誉为“睿智之士”，是中国历史上著名的政治家、军事家、文学家、发明家。</p>
<h3 id="全文"><a href="#全文" class="headerlink" title="全文"></a>全文</h3><p>先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必能裨补阙漏，有所广益。将军向宠，性行淑均，晓畅军事，试用于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐托付不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。今当远离，临表涕零，不知所言。</p>
]]></content>
  </entry>
  <entry>
    <title>基本排序</title>
    <url>/2023/12/11/algorithm/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BubbleSort</span><span class="params">(s []<span class="type">int64</span>)</span></span> []<span class="type">int64</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(s) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> s[j] &gt; s[j+<span class="number">1</span>] &#123;</span><br><span class="line">				s[j], s[j+<span class="number">1</span>] = s[j+<span class="number">1</span>], s[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SelectionSort</span><span class="params">(s []<span class="type">int64</span>)</span></span> []<span class="type">int64</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		curMinIdx := i</span><br><span class="line">		<span class="keyword">for</span> j := i; j &lt; <span class="built_in">len</span>(s); j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> s[j] &lt; s[curMinIdx] &#123;</span><br><span class="line">				curMinIdx = j</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		s[i], s[curMinIdx] = s[curMinIdx], s[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertionSort</span><span class="params">(s []<span class="type">int64</span>)</span></span> []<span class="type">int64</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> ; i &gt; <span class="number">0</span> &amp;&amp; s[i<span class="number">-1</span>] &gt; s[i]; i-- &#123;</span><br><span class="line">			s[i<span class="number">-1</span>], s[i] = s[i], s[i<span class="number">-1</span>]</span><br><span class="line">			fmt.Println(s)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>输出二进制的字符串</title>
    <url>/2023/12/11/algorithm/%E8%BE%93%E5%87%BA%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>给一个数字，输出其二进制的字符串，这里我们使用 golang 中的<code>int32</code>举例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 20 -&gt; 00000000000000000000000000010100  最高为符号位，0为正数，1为负数</span><br><span class="line">// -1 -&gt; 11111111111111111111111111111111  负数等于后31位取反+1</span><br></pre></td></tr></table></figure></div>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>将 1 进行左移，一共进行 32 次，每次都和 num 进行与运算，如果是 0 则 num 的 i 位就是 0，否则就是 1。</p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintBinaryString</span><span class="params">(num <span class="type">int32</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> str <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> c <span class="type">int32</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">32</span>; i++ &#123;</span><br><span class="line">		c = <span class="number">1</span> &lt;&lt; i</span><br><span class="line">		<span class="keyword">if</span> num&amp;c != <span class="number">0</span> &#123;</span><br><span class="line">			str = <span class="string">&quot;1&quot;</span> + str</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			str = <span class="string">&quot;0&quot;</span> + str</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>【kubernetes】如何Debug Kubernetes源码</title>
    <url>/2023/10/22/kubernetes/%E5%A6%82%E4%BD%95Debug%20Kubernetes%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h2 id="前置步骤"><a href="#前置步骤" class="headerlink" title="前置步骤"></a>前置步骤</h2><ul>
<li>准备一台虚拟机（本来准备本地跑一跑，但是kubelet不支持Darwin，无奈Fusion运行一台centos7），需要安装golang环境</li>
<li>准备kubernets源码，本地和虚拟机中的要一致，本文以1.24.0分支为主，kubernetes的源码最好放在<code>k8s.io</code>下，如<code>/root/go/src/k8s.io/kubernetes</code></li>
</ul>
<h2 id="虚拟机安装"><a href="#虚拟机安装" class="headerlink" title="虚拟机安装"></a>虚拟机安装</h2><h3 id="安装cfssl"><a href="#安装cfssl" class="headerlink" title="安装cfssl"></a>安装cfssl</h3><p>需要安装cfssl和cfssljson，记得放到PATH下面。<br><a class="link"   href="https://github.com/cloudflare/cfssl/releases" >cfssl二进制文件 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="安装containerd"><a href="#安装containerd" class="headerlink" title="安装containerd"></a>安装containerd</h3><p>安装containerd，需要启动containerd。<br><a class="link"   href="https://github.com/containerd/containerd/blob/main/docs/getting-started.md" >containerd安装步骤 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="安装kubectl"><a href="#安装kubectl" class="headerlink" title="安装kubectl"></a>安装kubectl</h3><p>方便后面操作集群资源。</p>
<h3 id="安装etcd"><a href="#安装etcd" class="headerlink" title="安装etcd"></a>安装etcd</h3><p>在kubernetes的hack目录下，有安装脚本，可以执行安装;</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/go/src/k8s.io/kubernetes</span><br><span class="line">./hack/install-etcd.sh </span><br></pre></td></tr></table></figure></div>

<h3 id="修改打包参数"><a href="#修改打包参数" class="headerlink" title="修改打包参数"></a>修改打包参数</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">./hack/lib/golang.sh</span><br><span class="line"></span><br><span class="line">    gogcflags=<span class="string">&quot;all=-trimpath=<span class="variable">$&#123;trimroot&#125;</span> <span class="variable">$&#123;GOGCFLAGS:-&#125;</span>&quot;</span></span><br><span class="line">    <span class="comment"># 注释下面的行</span></span><br><span class="line">    <span class="comment">#if [[ &quot;$&#123;DBG:-&#125;&quot; == 1 ]]; then</span></span><br><span class="line">    <span class="comment">#    # Debugging - disable optimizations and inlining.</span></span><br><span class="line">    <span class="comment">#    gogcflags=&quot;$&#123;gogcflags&#125; -N -l&quot;</span></span><br><span class="line">    <span class="comment">#fi</span></span><br><span class="line">    <span class="comment"># 添加下面的行</span></span><br><span class="line">    gogcflags=<span class="string">&quot;<span class="variable">$&#123;gogcflags&#125;</span> -N -l&quot;</span></span><br><span class="line"></span><br><span class="line">    goldflags=<span class="string">&quot;all=<span class="subst">$(kube::version::ldflags)</span> <span class="variable">$&#123;GOLDFLAGS:-&#125;</span>&quot;</span></span><br><span class="line">    <span class="comment"># 注释下面的行</span></span><br><span class="line">    <span class="comment">#if [[ &quot;$&#123;DBG:-&#125;&quot; != 1 ]]; then</span></span><br><span class="line">    <span class="comment">#    # Not debugging - disable symbols and DWARF.</span></span><br><span class="line">    <span class="comment">#    goldflags=&quot;$&#123;goldflags&#125; -s -w&quot;</span></span><br><span class="line">    <span class="comment">#fi</span></span><br></pre></td></tr></table></figure></div>

<h3 id="安装dlv"><a href="#安装dlv" class="headerlink" title="安装dlv"></a>安装dlv</h3><p>dlv是golang的debug的工具，详细可以参考<a class="link"   href="https://github.com/go-delve/delve/tree/master/Documentation/usage" >文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">go install github.com/go-delve/delve/cmd/dlv@latest</span><br></pre></td></tr></table></figure></div>

<h2 id="Debug步骤"><a href="#Debug步骤" class="headerlink" title="Debug步骤"></a>Debug步骤</h2><h3 id="在虚拟机中运行本地集群"><a href="#在虚拟机中运行本地集群" class="headerlink" title="在虚拟机中运行本地集群"></a>在虚拟机中运行本地集群</h3><p><code>hack</code>目录中的<code>local-up-cluster.sh</code>可以直接运行单节点本地集群，如果修改了代码进行调试，记得执行<code>make clean</code>。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">./hack/local-up-cluster.sh </span><br></pre></td></tr></table></figure></div>
<p>等待一段时间后，可以使用kubectl验证一下集群是否正常启动成功:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> KUBECONFIG=/var/run/kubernetes/admin.kubeconfig</span><br><span class="line">$ kubectl  cluster-info </span><br><span class="line">Kubernetes control plane is running at https://localhost:6443/</span><br><span class="line">CoreDNS is running at https://localhost:6443//api/v1/namespaces/kube-system/services/kube-dns:dns/proxy</span><br></pre></td></tr></table></figure></div>


<p>这里以<code>debug apiserver</code>举例，其他的组件类似。</p>
<h3 id="dlv重新运行apiserver"><a href="#dlv重新运行apiserver" class="headerlink" title="dlv重新运行apiserver"></a>dlv重新运行apiserver</h3><p>找到apiserver的进程，使用<code>kill</code>命令将apiserver进程kill掉，使用<code>dlv</code>运行apiserver。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ ps axu|grep kube-apiserver</span><br><span class="line">$ <span class="built_in">kill</span> -9 PID</span><br><span class="line">$ dlv <span class="built_in">exec</span> /root/go/src/k8s.io/kubernetes/_output/local/bin/linux/amd64/kube-apiserver --headless --listen=:2345 --api-version=2 --accept-multiclient -- --authorization-mode=Node,RBAC  --cloud-provider= --cloud-config=   --v=3 --vmodule= --audit-policy-file=/tmp/kube-audit-policy-file --audit-log-path=/tmp/kube-apiserver-audit.log --authorization-webhook-config-file= --authentication-token-webhook-config-file= --cert-dir=/var/run/kubernetes --egress-selector-config-file=/tmp/kube_egress_selector_configuration.yaml --client-ca-file=/var/run/kubernetes/client-ca.crt --kubelet-client-certificate=/var/run/kubernetes/client-kube-apiserver.crt --kubelet-client-key=/var/run/kubernetes/client-kube-apiserver.key --service-account-key-file=/tmp/kube-serviceaccount.key --service-account-lookup=<span class="literal">true</span> --service-account-issuer=https://kubernetes.default.svc --service-account-jwks-uri=https://kubernetes.default.svc/openid/v1/jwks --service-account-signing-key-file=/tmp/kube-serviceaccount.key --enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,Priority,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota,NodeRestriction --disable-admission-plugins= --admission-control-config-file= --bind-address=0.0.0.0 --secure-port=6443 --tls-cert-file=/var/run/kubernetes/serving-kube-apiserver.crt --tls-private-key-file=/var/run/kubernetes/serving-kube-apiserver.key --storage-backend=etcd3 --storage-media-type=application/vnd.kubernetes.protobuf --etcd-servers=http://127.0.0.1:2379 --service-cluster-ip-range=10.0.0.0/24 --feature-gates=AllAlpha=<span class="literal">false</span> --external-hostname=localhost --requestheader-username-headers=X-Remote-User --requestheader-group-headers=X-Remote-Group --requestheader-extra-headers-prefix=X-Remote-Extra- --requestheader-client-ca-file=/var/run/kubernetes/request-header-ca.crt --requestheader-allowed-names=system:auth-proxy --proxy-client-cert-file=/var/run/kubernetes/client-auth-proxy.crt --proxy-client-key-file=/var/run/kubernetes/client-auth-proxy.key --cors-allowed-origins=<span class="string">&quot;/127.0.0.1(:[0-9]+)?$,/localhost(:[0-9]+)?$&quot;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="使用goland连接"><a href="#使用goland连接" class="headerlink" title="使用goland连接"></a>使用goland连接</h3><p>配置goland，连接dlv服务端<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/kubernetes/apiserver-debug.png"
                      alt="apiserver-debug"
                ><br>设置断点，启动debug，就可以愉快的Debug了。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/kubernetes/apiserver-main-debug.png"
                      alt="apiserver-main-debug"
                ></p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>求数组的n到m项的和</title>
    <url>/2023/12/11/algorithm/%E6%B1%82%E6%95%B0%E7%BB%84%E7%9A%84n%E5%88%B0m%E9%A1%B9%E7%9A%84%E5%92%8C/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>有一个数组 arr,求其 n 到 m 项的和，m&gt;&#x3D;n，比如[5, 4, -1, 10, 1, 2, 6, 9]，求其 2 到 7 项的和，即-1+10+1+2+6+9&#x3D;27。</p>
<h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法 1"></a>解法 1</h2><p>构建一个二维的数组，想要获取 n 到 m 项的和，直接通过索引获取即可，改方法的好处就是构建一次二维数组，后续查找 n 到 m 项的和的复杂度位 1，也不需要进行额外的计算了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/algorithm/n2msumway1.png"
                      alt="n2msumway1"
                ></p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">n2mSumWay1</span><span class="params">(arr []<span class="type">int64</span>, n, m <span class="type">int64</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">	table := <span class="built_in">make</span>([][]<span class="type">int64</span>, <span class="number">0</span>, <span class="built_in">len</span>(arr))</span><br><span class="line">	<span class="keyword">for</span> i1, v1 := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		row := <span class="built_in">make</span>([]<span class="type">int64</span>, <span class="number">0</span>, <span class="built_in">len</span>(arr))</span><br><span class="line">		<span class="keyword">for</span> i2, v2 := <span class="keyword">range</span> arr &#123;</span><br><span class="line">			<span class="keyword">if</span> i2 == i1 &#123;</span><br><span class="line">				row = <span class="built_in">append</span>(row, v1)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> i2 &gt; i1 &#123;</span><br><span class="line">				row = <span class="built_in">append</span>(row, v2+row[i2<span class="number">-1</span>])</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				row = <span class="built_in">append</span>(row, <span class="number">0</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		table = <span class="built_in">append</span>(table, row)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> m &lt; n &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;请输入合法的m和n，m必须大于等于n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> table[n][m]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="解法-2"><a href="#解法-2" class="headerlink" title="解法 2"></a>解法 2</h2><p>构建一个前缀和数组 preArr</p>
<ul>
<li>如果 n 是 0，获取 n 到 m 的和，返回该前缀和数组的第 m 项的值</li>
<li>如果 n 不是 0，获取 n 到 m 的和，返回 preArr[m]-preArr[n-1]的值</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/algorithm/n2msumway2.png"
                      alt="n2msumway2"
                ></p>
<div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">n2mSumWay2</span><span class="params">(arr []<span class="type">int64</span>, n, m <span class="type">int64</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">	preArr := <span class="built_in">make</span>([]<span class="type">int64</span>, <span class="number">0</span>, <span class="built_in">len</span>(arr))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">			preArr = <span class="built_in">append</span>(preArr, v)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			preArr = <span class="built_in">append</span>(preArr, preArr[i<span class="number">-1</span>]+v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n &gt; m &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;请输入合法的m和n，m必须大于等于n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> preArr[m]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> preArr[m] - preArr[n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>【网络】容器网络基础实践</title>
    <url>/2024/02/26/network/%E3%80%90%E7%BD%91%E7%BB%9C%E3%80%91%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>容器技术中的 Namespace 是 Linux 内核的一个功能，它使得容器可以在同一主机上共享同一系统资源，但是各自拥有独立的视图和感知，从而可以实现容器的隔离和安全性。Namespace 分为以下几种类型：</p>
<p>Mount Namespace（挂载命名空间）：每个容器都有自己的挂载命名空间，可以独立挂载文件系统，使得容器之间不会影响到其他容器的文件系统。一个容器的挂载命名空间改变不会影响到其他容器的挂载命名空间。</p>
<p>UTS Namespace（UTS 命名空间）：每个容器都有自己的主机名和域名，使得容器之间的主机名和域名是隔离的。</p>
<p>PID Namespace（PID 命名空间）：每个容器都有自己的进程命名空间，使得容器内的进程 ID 和主机上的进程 ID 是隔离的。这样做可以避免容器内的进程影响到宿主机上的进程。</p>
<p>Network Namespace（网络命名空间）：每个容器都有自己的网络命名空间，使得容器之间的网络资源是隔离的。这样做可以使得容器之间有自己的网络接口和 IP 地址。</p>
<p>IPC Namespace（IPC 命名空间）：每个容器都有自己的 IPC 命名空间，使得容器之间的进程间通信资源是隔离的。</p>
<p>User Namespace（用户命名空间）：每个容器都有自己的用户命名空间，使得容器之间的用户和用户组是隔离的。</p>
<p>在容器中使用 Namespace 功能，可以有效地隔离容器和宿主机，使得容器之间不会互相影响。这样做可以使得容器更加安全、可靠和高效。</p>
<h2 id="veth-设备"><a href="#veth-设备" class="headerlink" title="veth 设备"></a>veth 设备</h2><p>veth 是 Linux 内核中的虚拟以太网设备 (Virtual Ethernet Device)，用于连接两个命名空间 (Namespace) 中的网络栈。在容器化环境中，每个容器都有一个网络命名空间，veth 设备通常用于将容器的网络栈连接到宿主机的网络栈，从而实现容器之间的通信。</p>
<p>在使用 veth 设备时，通常会创建一对相互连接的 veth 设备，这对设备的一个端点（一般记作 veth0）会被移动到容器的网络命名空间中，另一个端点则保留在宿主机的网络命名空间中（一般记作 veth1）。这样做会使得两个网络命名空间相互隔离，但容器和宿主机之间仍然可以通信。</p>
<p>veth 设备在实现容器网络隔离的同时，还能够通过 Linux 网桥 (bridge) 或者 Linux 路由器来实现不同容器之间的通信。在 veth 设备的两端设置 IP 地址，并将它们连接到一个 Linux 网桥上，可以使得多个容器之间能够互相通信。此外，veth 设备也可以与宿主机的物理网卡连接，从而实现容器和外部网络的通信。</p>
<p>veth 设备的工作原理是，将发送到其中一个端点的数据包，从另一个端点转发出去，这样做可以使得容器内的网络流量能够流向宿主机的网络栈，也可以使得外部网络的数据流量能够流向容器的网络栈。因此，veth 设备是容器网络隔离的基础之一，在容器化环境中被广泛使用。</p>
<h2 id="模拟容器网络拓扑"><a href="#模拟容器网络拓扑" class="headerlink" title="模拟容器网络拓扑"></a>模拟容器网络拓扑</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/network/network0.png"
                      alt="tp0"
                ><br>这里我们使用 namespace server0、server1、server2 和 server3 模拟各个容器。</p>
<h2 id="单个主机上容器和容器的通信"><a href="#单个主机上容器和容器的通信" class="headerlink" title="单个主机上容器和容器的通信"></a>单个主机上容器和容器的通信</h2><p>在 192.168.209.3 上创建两个 namespace 代替 server0 和 server1</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ip netns add server0</span><br><span class="line">ip netns add server1</span><br><span class="line">ip netns show</span><br></pre></td></tr></table></figure></div>

<p>创建连接 server0 和 root namespace 的 veth 设备</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span> add veth0 <span class="built_in">type</span> veth peer name seth0</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> veth0 up</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> seth0 netns server0 <span class="comment"># 将seth0 接口放在server0的namespace</span></span><br></pre></td></tr></table></figure></div>

<p>进入到 server0 中</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> server0 bash</span><br><span class="line">ip <span class="built_in">link</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> lo up</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> seth0 up</span><br><span class="line">ip addr add 172.168.3.2/24 dev seth0</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure></div>

<p>server1 类似</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span> add veth1 <span class="built_in">type</span> veth peer name seth1</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> veth1 up</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> seth1 netns server1 <span class="comment"># 将seth0 接口放在server1namespace</span></span><br><span class="line"></span><br><span class="line">ip netns <span class="built_in">exec</span> server1 bash</span><br><span class="line">ip <span class="built_in">link</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> lo up</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> seth1 up</span><br><span class="line">ip addr add 172.168.3.3/24 dev seth1</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure></div>

<p>创建一个 br0 的 bridge 设备</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span> add br0 <span class="built_in">type</span> bridge</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> br0 up</span><br></pre></td></tr></table></figure></div>

<p>将刚才两个网线插到交换机上</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> veth0 master br0</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> veth1 master br0</span><br></pre></td></tr></table></figure></div>

<p>server0 和 server1 就可以通信了</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> server1 bash</span><br><span class="line">ip add show</span><br><span class="line">ping 172.168.3.2</span><br></pre></td></tr></table></figure></div>

<p>这个时候会发现不能 ping 通宿主机的网络</p>
<p>给 br0 分配一个 IP 地址</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ip addr add 172.168.3.1/24 dev br0</span><br></pre></td></tr></table></figure></div>

<p>给 br0 分配了 ip 地址后，在 server0 和 server1 上就会生成一条路由</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ip netns  <span class="built_in">exec</span> server0 ip route</span><br><span class="line">172.168.3.0/24 dev seth0 proto kernel scope <span class="built_in">link</span> src 172.168.3.2</span><br></pre></td></tr></table></figure></div>

<p>这个时候主机就可以 ping 通容器了，但是如果需要容器也 ping 通宿主机的网卡地址，就需要在 server0 和 server1 上添加一条默认路由</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> server0 bash</span><br><span class="line">ip route add default via 172.168.3.1</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">ip netns <span class="built_in">exec</span> server1 bash</span><br><span class="line">ip route add default via 172.168.3.1</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure></div>

<p>server0 和 server1 就可以 ping 通主机了。</p>
<p>同样的道理来在主机 192.168.209.4 上配置一下 server2 和 server3</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ip netns add server2</span><br><span class="line">ip netns add server3</span><br><span class="line"></span><br><span class="line">ip <span class="built_in">link</span> add veth0 <span class="built_in">type</span> veth peer name seth0</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> veth0 up</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> seth0 netns server2</span><br><span class="line"></span><br><span class="line">ip netns <span class="built_in">exec</span> server2 bash</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> lo up</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> seth0 up</span><br><span class="line">ip addr add 172.168.4.2/24 dev seth0</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">ip <span class="built_in">link</span> add veth1 <span class="built_in">type</span> veth peer name seth1</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> veth1 up</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> seth1 netns server3</span><br><span class="line"></span><br><span class="line">ip netns <span class="built_in">exec</span> server3 bash</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> lo up</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> seth1 up</span><br><span class="line">ip addr add 172.168.4.3/24 dev seth1</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ip <span class="built_in">link</span> add br1 <span class="built_in">type</span> bridge</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> br1 up</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> veth0 master br1</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> veth1 master br1</span><br><span class="line"></span><br><span class="line">ip addr add 172.168.4.1/24 dev br1</span><br><span class="line"></span><br><span class="line">ip netns <span class="built_in">exec</span> server2 bash</span><br><span class="line">ip route add default via 172.168.4.1</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">ip netns <span class="built_in">exec</span> server3 bash</span><br><span class="line">ip route add default via 172.168.4.1</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure></div>

<h2 id="主机之间容器的通信"><a href="#主机之间容器的通信" class="headerlink" title="主机之间容器的通信"></a>主机之间容器的通信</h2><p>需要两台主机开启<code>net.ipv4.ip_forward = 1</code><br>在 192.168.209.3 上需要添加路由</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ip route add 172.168.4.0/24 via 192.168.209.4 dev ens33</span><br></pre></td></tr></table></figure></div>

<p>在 192.168.209.4 上需要添加路由</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ip route add 172.168.3.0/24 via 192.168.209.3 dev ens33</span><br></pre></td></tr></table></figure></div>

<p>宿主机上的 server 之间就可以通信了</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> server3 bash</span><br><span class="line">ping 172.168.3.3</span><br><span class="line">PING 172.168.3.3 (172.168.3.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.168.3.3: icmp_seq=1 ttl=62 time=0.458 ms</span><br><span class="line">64 bytes from 172.168.3.3: icmp_seq=2 ttl=62 time=1.20 ms</span><br><span class="line">64 bytes from 172.168.3.3: icmp_seq=3 ttl=62 time=0.941 ms</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure></div>

<h2 id="容器访问外网"><a href="#容器访问外网" class="headerlink" title="容器访问外网"></a>容器访问外网</h2><p>这个时候容器是无法访问外部网络的</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ping -c 2 www.baidu.com</span><br><span class="line">^C</span><br></pre></td></tr></table></figure></div>

<p>需要在宿主机 192.168.209.3 上配置 nat</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 172.168.3.0/24 ! -o br0 -j MASQUERADE</span><br></pre></td></tr></table></figure></div>

<p>需要在宿主机 192.168.209.4 上配置 nat</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 172.168.4.0/24 ! -o br1 -j MASQUERADE</span><br></pre></td></tr></table></figure></div>

<p>这个时候就可以访问外部网络了</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ping -c 2 www.baidu.com</span><br><span class="line">PING www.a.shifen.com (180.101.50.188) 56(84) bytes of data.</span><br><span class="line">64 bytes from 180.101.50.188 (180.101.50.188): icmp_seq=1 ttl=49 time=9.15 ms</span><br><span class="line">64 bytes from 180.101.50.188 (180.101.50.188): icmp_seq=2 ttl=49 time=9.51 ms</span><br><span class="line"></span><br><span class="line">--- www.a.shifen.com ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1002ms</span><br><span class="line">rtt min/avg/max/mdev = 9.159/9.337/9.515/0.178 ms</span><br></pre></td></tr></table></figure></div>

<h2 id="端口发布"><a href="#端口发布" class="headerlink" title="端口发布"></a>端口发布</h2><p>实现可以通过主机的端口访问容器的端口，类似于 docker 的<code>-p</code>选项<br>我们在 server0 上监听一个端口</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ip netns <span class="built_in">exec</span> server0 bash</span><br><span class="line">nc -kl 172.168.3.2 5000</span><br></pre></td></tr></table></figure></div>

<p>在主机 192.168.209.3 配置 DNAT</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -d 192.168.209.3 -p tcp -m tcp --dport 5000 -j DNAT --to-destination 172.168.3.2:5000 <span class="comment"># 来自主机外部的流量</span></span><br><span class="line">iptables -t nat -A OUTPUT -d 192.168.209.3 -p tcp -m tcp --dport 5000 -j DNAT --to-destination 172.168.3.2:5000 <span class="comment"># 主机本身不会经过PREROUTING链，需要在OUTPUT上配置</span></span><br></pre></td></tr></table></figure></div>

<p>测试</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">nc 172.168.3.2 5000</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
</search>
